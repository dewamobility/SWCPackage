// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SWCFramework
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Combine
import CommonCrypto
import CoreGraphics
import CryptoKit
import Foundation
@_exported import SWCFramework
import Security
import Swift
import SwiftUI
import UIKit
import _Concurrency
import _StringProcessing
public protocol SWCRequestSource {
  func generateRequest() -> Foundation.URLRequest
  var showLoader: Swift.Bool { get }
  var validateTokenTimeStamp: Swift.Bool { get }
}
extension SWCFramework.SWCRequestSource {
  public var validateTokenTimeStamp: Swift.Bool {
    get
  }
  public var showLoader: Swift.Bool {
    get
  }
}
public enum ContentTypes : Swift.String {
  case json
  case jsonOdataVerbose
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HTTPHeaders : Swift.String {
  case accept
  case contentType
  case xRequestDigest
  case XHTTPMethod
  case iFMATCH
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HTTPMethod : Swift.String {
  case post, get
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class SwiftRSA {
  @objc deinit
}
public struct SWCResponseValidator {
  public let isValid: Swift.Bool
  public let error: Swift.Error?
  public init(isValid: Swift.Bool, error: Swift.Error?)
}
extension SWCFramework.SWCResponseValidator {
  public static let `default`: SWCFramework.SWCResponseValidatorDelegate
  public static let none: SWCFramework.SWCResponseValidatorDelegate
}
public struct SWCAttachment : Swift.Encodable {
  public let fileId: Swift.String
  public let fileName: Swift.String
  public let mimeType: Swift.String
  public let fileData: Swift.String
  public let fileDescription: Swift.String
  public let status: Swift.String
  public init(fileId: Swift.String, fileName: Swift.String, mimeType: Swift.String, fileData: Swift.String, fileDescription: Swift.String, status: Swift.String = "")
  public func encode(to encoder: Swift.Encoder) throws
}
@objc @_inheritsConvenienceInitializers public class SWCUploadEngine : ObjectiveC.NSObject {
  public static let shared: SWCFramework.SWCUploadEngine
  public func upload<T>(with source: T) -> SWCFramework.SWCProgressPublisher where T : SWCFramework.SWCUploadSource
  @objc override dynamic public init()
  @objc deinit
}
extension SWCFramework.SWCUploadEngine : Foundation.URLSessionTaskDelegate {
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
}
extension SWCFramework.SWCUploadEngine : Foundation.URLSessionDelegate {
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
public struct SWCRequestBody : Swift.Encodable {
  public var otherParams: [Swift.String : Swift.String]?
  public let reqGuId: Swift.String
  public var apiKey: Swift.String? {
    get
    set
  }
  public var thakkolKey: Swift.String? {
    get
  }
  public var requester: Swift.String? {
    get
  }
  public var loginPassword: Swift.String?
  public var loginUsername: Swift.String?
  public var attachments: [SWCFramework.SWCAttachment]?
  public var values: [SWCFramework.SWCRequestValues]?
  public var encryptionType: SWCFramework.EncryptionType
  public var moduleId: Swift.String?
  public var additionalChunks: [Swift.String : Any]
  public var kpiLogs: [SWCFramework.KPINetworkModel]?
  public func encode(to encoder: Swift.Encoder) throws
}
public struct DDriveUploadGenerator : SWCFramework.SWCUploadSource {
  public var showLoader: Swift.Bool
  public var fromFileURL: Foundation.URL
  public init(urlString: Swift.String, fromFileURL: Foundation.URL, digestKey: Swift.String)
  public func generateRequest() -> Foundation.URLRequest
}
public class PublicKey : SWCFramework.Key {
  final public let key: Security.SecKey
  required public init(key: Security.SecKey)
  required public init?(der data: Foundation.Data)
  public func pemString() throws -> Swift.String
  @objc deinit
}
open class KeychainWrapper {
  @available(*, deprecated, message: "KeychainWrapper.defaultKeychainWrapper is deprecated since version 2.2.1, use KeychainWrapper.standard instead")
  public static let defaultKeychainWrapper: SWCFramework.KeychainWrapper
  public static let standard: SWCFramework.KeychainWrapper
  public var serviceName: Swift.String {
    get
  }
  public var accessGroup: Swift.String? {
    get
  }
  public init(serviceName: Swift.String, accessGroup: Swift.String? = nil)
  open func hasValue(forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  open func accessibilityOfKey(_ key: Swift.String) -> SWCFramework.KeychainItemAccessibility?
  open func allKeys() -> Swift.Set<Swift.String>
  open func integer(forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Int?
  open func float(forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Float?
  open func double(forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Double?
  open func bool(forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool?
  open func string(forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.String?
  open func object(forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Foundation.NSCoding?
  open func data(forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Foundation.Data?
  open func dataRef(forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Foundation.Data?
  @discardableResult
  open func set(_ value: Swift.Int, forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Float, forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Double, forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Bool, forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.String, forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Foundation.NSCoding, forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Foundation.Data, forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @available(*, deprecated, message: "remove is deprecated since version 2.2.1, use removeObject instead")
  @discardableResult
  open func remove(key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func removeObject(forKey key: Swift.String, withAccessibility accessibility: SWCFramework.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func removeAllKeys() -> Swift.Bool
  open class func wipeKeychain()
  @objc deinit
}
public struct SWCRequestComponents {
  public var url: Swift.String
  public var contentType: SWCFramework.ContentTypes
  public var accept: SWCFramework.ContentTypes
  public var httpMethod: SWCFramework.HTTPMethod
  public var body: SWCFramework.SWCRequestBody
  public init(url: Swift.String)
}
public class ClearText {
  final public let data: Foundation.Data
  public var stringValue: Swift.String {
    get
  }
  required public init(data: Foundation.Data)
  required public init(string: Swift.String)
  public func encrypted(with key: SWCFramework.PublicKey, by algorithm: Security.SecKeyAlgorithm) throws -> SWCFramework.EncryptedText
  public static func maxClearTextInLength(_ key: Security.SecKey, algorithm: Security.SecKeyAlgorithm) throws -> Swift.Int
  @objc deinit
}
public protocol Key : AnyObject {
  var key: Security.SecKey { get }
  init(key: Security.SecKey)
  init?(der data: Foundation.Data)
  init?(pemEncoded pemString: Swift.String)
  init?(base64Encoded base64String: Swift.String)
  func data() throws -> Foundation.Data
  func pemString() throws -> Swift.String
  func base64String() throws -> Swift.String
}
extension SWCFramework.Key {
  public init?(base64Encoded base64String: Swift.String)
  public init?(pemEncoded pemString: Swift.String)
  public func data() throws -> Foundation.Data
  public func base64String() throws -> Swift.String
}
public class EncryptedText {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data, by algo: Security.SecKeyAlgorithm)
  public func decrypted(with key: SWCFramework.PrivateKey) throws -> SWCFramework.ClearText
  @objc deinit
}
public enum SWCResponseCode : Swift.Int, Swift.Error {
  case success
  case invalidToken
  case expiredToken
  case badReqeust
  case failedRequest
  case noDataFound
  case invalidUsercredentials
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum Language : Swift.String {
  case english
  case arabic
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class AppLanguage {
  public static var current: SWCFramework.Language {
    get
  }
  public static func didChangeLanguage() -> Swift.Bool
  @objc deinit
}
public struct Random {
  public static func generate(_ upperBound: Swift.Int) -> Swift.Int
}
@_hasMissingDesignatedInitializers final public class AES256CBC {
  final public class func encryptString(_ str: Swift.String, key: Swift.String, iv: Swift.String) -> Swift.String?
  final public class func encrypt(string: Swift.String, password: Swift.String) -> (encryptedData: Foundation.Data, IV: Swift.String)?
  final public class func decryptString(_ str: Swift.String, password: Swift.String) -> Swift.String?
  final public class func decryptString(_ data: Foundation.Data, iv: Foundation.Data, key: Swift.String) -> Swift.String?
  final public class func generatePassword() -> Swift.String
  final public class func randomText(_ length: Swift.Int, justLowerCase: Swift.Bool = false, whitespace: Swift.Bool = false) -> Swift.String
  @objc deinit
}
public enum NetworkError : Swift.Error, Swift.Equatable {
  case invalidResponseFormat, unknown
  case missingResponseCode
  case noDataFound(error: Swift.String)
  case customError(error: Swift.String)
  case httpError(Foundation.HTTPURLResponse)
  case urlError(Foundation.URLError)
  case passwordExpiry(error: Swift.String)
  public static func == (a: SWCFramework.NetworkError, b: SWCFramework.NetworkError) -> Swift.Bool
}
extension SWCFramework.NetworkError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class XMLHashOptions {
  public var shouldProcessLazily: Swift.Bool
  public var shouldProcessNamespaces: Swift.Bool
  public var caseInsensitive: Swift.Bool
  public var encoding: Swift.String.Encoding
  public var userInfo: [Swift.CodingUserInfoKey : Any]
  public var detectParsingErrors: Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers public class XMLHash {
  public class func config(_ configAction: (SWCFramework.XMLHashOptions) -> Swift.Void) -> SWCFramework.XMLHash
  public func parse(_ xml: Swift.String) -> SWCFramework.XMLIndexer
  public func parse(_ data: Foundation.Data) -> SWCFramework.XMLIndexer
  public class func parse(_ xml: Swift.String) -> SWCFramework.XMLIndexer
  public class func parse(_ data: Foundation.Data) -> SWCFramework.XMLIndexer
  public class func lazy(_ xml: Swift.String) -> SWCFramework.XMLIndexer
  public class func lazy(_ data: Foundation.Data) -> SWCFramework.XMLIndexer
  @objc deinit
}
@_hasMissingDesignatedInitializers public class IndexOp {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class IndexOps {
  @objc deinit
}
public struct ParsingError : Swift.Error {
  public let line: Swift.Int
  public let column: Swift.Int
}
public enum IndexingError : Swift.Error {
  case attribute(attr: Swift.String)
  case attributeValue(attr: Swift.String, value: Swift.String)
  case key(key: Swift.String)
  case index(idx: Swift.Int)
  case initialize(instance: Swift.AnyObject)
  case encoding
  case error
  @available(*, unavailable, renamed: "attribute(attr:)")
  public static func Attribute(attr: Swift.String) -> SWCFramework.IndexingError
  @available(*, unavailable, renamed: "attributeValue(attr:value:)")
  public static func AttributeValue(attr: Swift.String, value: Swift.String) -> SWCFramework.IndexingError
  @available(*, unavailable, renamed: "key(key:)")
  public static func Key(key: Swift.String) -> SWCFramework.IndexingError
  @available(*, unavailable, renamed: "index(idx:)")
  public static func Index(idx: Swift.Int) -> SWCFramework.IndexingError
  @available(*, unavailable, renamed: "initialize(instance:)")
  public static func Init(instance: Swift.AnyObject) -> SWCFramework.IndexingError
  @available(*, unavailable, renamed: "error")
  public static var Error: SWCFramework.IndexingError {
    get
  }
}
public enum XMLIndexer {
  case element(SWCFramework.XMLElement)
  case list([SWCFramework.XMLElement])
  case stream(SWCFramework.IndexOps)
  case xmlError(SWCFramework.IndexingError)
  case parsingError(SWCFramework.ParsingError)
  @available(*, unavailable, renamed: "element(_:)")
  public static func Element(_: SWCFramework.XMLElement) -> SWCFramework.XMLIndexer
  @available(*, unavailable, renamed: "list(_:)")
  public static func List(_: [SWCFramework.XMLElement]) -> SWCFramework.XMLIndexer
  @available(*, unavailable, renamed: "stream(_:)")
  public static func Stream(_: SWCFramework.IndexOps) -> SWCFramework.XMLIndexer
  @available(*, unavailable, renamed: "xmlError(_:)")
  public static func XMLError(_: SWCFramework.IndexingError) -> SWCFramework.XMLIndexer
  @available(*, unavailable, renamed: "withAttribute(_:_:)")
  public static func withAttr(_ attr: Swift.String, _ value: Swift.String) throws -> SWCFramework.XMLIndexer
  public var element: SWCFramework.XMLElement? {
    get
  }
  public var unwrappedValue: Swift.String {
    get
  }
  public var all: [SWCFramework.XMLIndexer] {
    get
  }
  public var children: [SWCFramework.XMLIndexer] {
    get
  }
  @available(*, unavailable, renamed: "filterChildren(_:)")
  public func filter(_ included: (_ elem: SWCFramework.XMLElement, _ index: Swift.Int) -> Swift.Bool) -> SWCFramework.XMLIndexer
  public func filterChildren(_ included: (_ elem: SWCFramework.XMLElement, _ index: Swift.Int) -> Swift.Bool) -> SWCFramework.XMLIndexer
  public func filterAll(_ included: (_ elem: SWCFramework.XMLElement, _ index: Swift.Int) -> Swift.Bool) -> SWCFramework.XMLIndexer
  public var userInfo: [Swift.CodingUserInfoKey : Any] {
    get
  }
  public func withAttribute(_ attr: Swift.String, _ value: Swift.String) throws -> SWCFramework.XMLIndexer
  public init(_ rawObject: Swift.AnyObject) throws
  public init(_ elem: SWCFramework.XMLElement)
  public func byKey(_ key: Swift.String) throws -> SWCFramework.XMLIndexer
  public subscript(key: Swift.String) -> SWCFramework.XMLIndexer {
    get
  }
  public func byIndex(_ index: Swift.Int) throws -> SWCFramework.XMLIndexer
  public subscript(index: Swift.Int) -> SWCFramework.XMLIndexer {
    get
  }
}
extension SWCFramework.XMLIndexer : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SWCFramework.IndexingError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol XMLContent : Swift.CustomStringConvertible {
}
@_hasMissingDesignatedInitializers public class TextElement : SWCFramework.XMLContent {
  final public let text: Swift.String
  @objc deinit
}
public struct XMLAttribute {
  public let name: Swift.String
  public let text: Swift.String
}
@_hasMissingDesignatedInitializers public class XMLElement : SWCFramework.XMLContent {
  final public let name: Swift.String
  public var caseInsensitive: Swift.Bool {
    get
  }
  public var allAttributes: [Swift.String : SWCFramework.XMLAttribute]
  public func attribute(by name: Swift.String) -> SWCFramework.XMLAttribute?
  public var text: Swift.String {
    get
  }
  public var recursiveText: Swift.String {
    get
  }
  public var innerXML: Swift.String {
    get
  }
  public var children: [SWCFramework.XMLContent]
  @objc deinit
}
extension SWCFramework.TextElement : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SWCFramework.XMLAttribute : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SWCFramework.XMLElement : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SWCFramework.XMLHash {
  public typealias XMLElement = SWCFramework.XMLHashXMLElement
}
public typealias XMLHashXMLElement = SWCFramework.XMLElement
extension SWCFramework.XMLIndexer {
  public func withAttribute<A, V>(_ attr: A, _ value: V) throws -> SWCFramework.XMLIndexer where A : Swift.RawRepresentable, V : Swift.RawRepresentable, A.RawValue == Swift.String, V.RawValue == Swift.String
  public func byKey<K>(_ key: K) throws -> SWCFramework.XMLIndexer where K : Swift.RawRepresentable, K.RawValue == Swift.String
  public subscript<K>(key: K) -> SWCFramework.XMLIndexer where K : Swift.RawRepresentable, K.RawValue == Swift.String {
    get
  }
}
extension SWCFramework.XMLElement {
  public func attribute<N>(by name: N) -> SWCFramework.XMLAttribute? where N : Swift.RawRepresentable, N.RawValue == Swift.String
}
public struct KPINetworkModel : Swift.Encodable {
  public init(moduleKey: Swift.String?, operationKey: Swift.String?, logType: Swift.String?, requestId: Swift.String?, remarks: Swift.String?, logDate: Swift.String?, recordId: Swift.String?)
  public func encode(to encoder: Swift.Encoder) throws
}
extension SWCFramework.SWCPackage {
  public struct UserData {
    public init(userName: Swift.String, password: Swift.String, userGUID: Swift.String, prNumber: Swift.String? = nil)
  }
  public struct Configuration {
    public init(tokenURL: Swift.String)
  }
}
extension UIKit.UIColor {
  public struct SWCTheme {
    public static let activeTabs: UIKit.UIColor
    public static let arrows: UIKit.UIColor
    public static let background: UIKit.UIColor
    public static let blue: UIKit.UIColor
    public static let cardBorder: UIKit.UIColor
    public static let cards: UIKit.UIColor
    public static let error: UIKit.UIColor
    public static let greyIcons: UIKit.UIColor
    public static let header: UIKit.UIColor
    public static let inputFields: UIKit.UIColor
    public static let lines: UIKit.UIColor
    public static let orange: UIKit.UIColor
    public static let placeholder: UIKit.UIColor
    public static let primary: UIKit.UIColor
    public static let primaryText: UIKit.UIColor
    public static let secondaryText: UIKit.UIColor
    public static let tabs: UIKit.UIColor
    public static let userCharacter: UIKit.UIColor
    public static let userIconBg: UIKit.UIColor
    public static let warning: UIKit.UIColor
  }
}
extension SwiftUI.Color {
  public struct SWCTheme {
    public static let activeTabs: SwiftUI.Color
    public static let arrows: SwiftUI.Color
    public static let background: SwiftUI.Color
    public static let blue: SwiftUI.Color
    public static let cardBorder: SwiftUI.Color
    public static let cards: SwiftUI.Color
    public static let error: SwiftUI.Color
    public static let greyIcons: SwiftUI.Color
    public static let header: SwiftUI.Color
    public static let inputFields: SwiftUI.Color
    public static let lines: SwiftUI.Color
    public static let orange: SwiftUI.Color
    public static let placeholder: SwiftUI.Color
    public static let primary: SwiftUI.Color
    public static let primaryText: SwiftUI.Color
    public static let secondaryText: SwiftUI.Color
    public static let tabs: SwiftUI.Color
    public static let userCharacter: SwiftUI.Color
    public static let userIconBg: SwiftUI.Color
    public static let warning: SwiftUI.Color
  }
}
@_hasMissingDesignatedInitializers final public class SWCPackage {
  public static func generateSWCIdentifier(for identifier: Swift.String) -> Swift.String?
  public static func configure(_ configuration: SWCFramework.SWCPackage.Configuration? = nil)
  public static func set(userData: SWCFramework.SWCPackage.UserData)
  public static func set(aesKey: Swift.String, aesIV: Swift.String)
  public static func set(rsaPublicKey: Swift.String)
  public static func set(moduleApiKey: Swift.String)
  public static func update(password: Swift.String)
  @objc deinit
}
public enum SwiftRSAError : Swift.Error {
  case emptyPEMKey
  case invalidBase64String
  case algorithmIsNotSupported
  case clearTextTooLong
  case addKeyFailed(error: CoreFoundation.CFError?)
  case encryptionFailed(error: CoreFoundation.CFError?)
  case decryptionFailed(error: CoreFoundation.CFError?)
  case externalRepresentationFailed(error: CoreFoundation.CFError?)
}
extension SWCFramework.KeychainWrapper {
  public func remove(forKey key: SWCFramework.KeychainWrapper.Key)
}
extension SWCFramework.KeychainWrapper {
  public subscript(key: SWCFramework.KeychainWrapper.Key) -> Swift.String? {
    get
    set
  }
  public subscript(key: SWCFramework.KeychainWrapper.Key) -> Swift.Bool? {
    get
    set
  }
  public subscript(key: SWCFramework.KeychainWrapper.Key) -> Swift.Int? {
    get
    set
  }
  public subscript(key: SWCFramework.KeychainWrapper.Key) -> Swift.Double? {
    get
    set
  }
  public subscript(key: SWCFramework.KeychainWrapper.Key) -> Swift.Float? {
    get
    set
  }
  public subscript(key: SWCFramework.KeychainWrapper.Key) -> CoreFoundation.CGFloat? {
    get
    set
  }
  public subscript(key: SWCFramework.KeychainWrapper.Key) -> Foundation.Data? {
    get
    set
  }
}
extension SWCFramework.KeychainWrapper {
  public func data(forKey key: SWCFramework.KeychainWrapper.Key) -> Foundation.Data?
  public func bool(forKey key: SWCFramework.KeychainWrapper.Key) -> Swift.Bool?
  public func integer(forKey key: SWCFramework.KeychainWrapper.Key) -> Swift.Int?
  public func float(forKey key: SWCFramework.KeychainWrapper.Key) -> Swift.Float?
  public func cgFloat(forKey key: SWCFramework.KeychainWrapper.Key) -> CoreFoundation.CGFloat?
  public func double(forKey key: SWCFramework.KeychainWrapper.Key) -> Swift.Double?
  public func string(forKey key: SWCFramework.KeychainWrapper.Key) -> Swift.String?
}
extension SWCFramework.KeychainWrapper {
  public struct Key : Swift.Hashable, Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
    public var rawValue: Swift.String
    public init(rawValue: Swift.String)
    public init(stringLiteral value: Swift.String)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias RawValue = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
  }
}
@objc @_inheritsConvenienceInitializers final public class UserDefaultsManager : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension SWCFramework.UserDefaultsManager {
  public static func save(value: Any, forKey key: Swift.String)
  public static func save(bool value: Swift.Bool, forKey key: Swift.String)
  public static func save(value: Any, forKey key: Foundation.UserDefaults.Key)
  public static func saveEncodable<T>(value: T, forKey key: Swift.String) where T : Swift.Encodable
  public static func saveEncodable<T>(value: T, forKey key: Foundation.UserDefaults.Key) where T : Swift.Encodable
}
extension SWCFramework.UserDefaultsManager {
  public static func value<T>(forType type: T.Type, forKey key: Swift.String) -> T? where T : Swift.Decodable
  public static func anyValue(forKey key: Swift.String) -> Any?
  public static func string(forKey key: Swift.String) -> Swift.String?
  public static func bool(forKey key: Swift.String) -> Swift.Bool
  public static func integer(forKey key: Swift.String) -> Swift.Int?
  public static func float(forKey key: Swift.String) -> Swift.Float?
  public static func removeObject(forKey key: Swift.String)
  public static func remoAllValues()
}
extension SWCFramework.UserDefaultsManager {
  public static func value<T>(forType type: T.Type, forKey key: Foundation.UserDefaults.Key) -> T? where T : Swift.Decodable
  public static func value(forKey key: Foundation.UserDefaults.Key) -> Any?
  public static func string(forKey key: Foundation.UserDefaults.Key) -> Swift.String?
  public static func bool(forKey key: Foundation.UserDefaults.Key) -> Swift.Bool
  public static func integer(forKey key: Foundation.UserDefaults.Key) -> Swift.Int?
  public static func float(forKey key: Foundation.UserDefaults.Key) -> Swift.Float?
  public static func removeObject(forKey key: Foundation.UserDefaults.Key)
}
extension Foundation.UserDefaults {
  public struct Key : Swift.ExpressibleByStringLiteral {
    public var rawValue: Swift.String
    public init(stringLiteral value: Swift.String)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
  }
}
public typealias UserDefaultsKey = Foundation.UserDefaults.Key
public struct SWCRequestValues : Swift.Encodable {
  public let value: Swift.String
  public var additionalValue: Swift.String
  public let propertyName: Swift.String
  public init(value: Swift.String, additionalValue: Swift.String = "", propertyName: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
}
public enum EncryptionType {
  case rsa, aes, none
  public static func == (a: SWCFramework.EncryptionType, b: SWCFramework.EncryptionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct SWCRequestGenerator {
  public var request: SWCFramework.SWCRequestComponents
  public var showLoader: Swift.Bool
  public var validateTokenTimeStamp: Swift.Bool
  public let engine: SWCFramework.SWCNetworkEngine
  public init(url: Swift.String, disablePasswordExpiryNotification: Swift.Bool = false)
}
extension SWCFramework.SWCRequestGenerator {
  public func getResponse<U>(responseType: U.Type, responseQueue: Dispatch.DispatchQueue = .main, jsonDecoder: Foundation.JSONDecoder = JSONDecoder()) -> SWCFramework.SWCResultObserver<U> where U : Swift.Decodable
  public func getResponse(responseQueue: Dispatch.DispatchQueue = .main) -> SWCFramework.SWCDictionaryResultObserver
}
extension SWCFramework.SWCRequestGenerator : SWCFramework.SWCRequestSource {
  public func generateRequest() -> Foundation.URLRequest
}
extension SWCFramework.SWCRequestGenerator {
  #if compiler(>=5.3) && $AsyncAwait
  public func getResponse<T>(responseType: T.Type, responseQueue: Dispatch.DispatchQueue = .main, jsonDecoder: Foundation.JSONDecoder = JSONDecoder()) async throws -> T where T : Swift.Decodable
  #endif
}
public protocol SWCBackgroundDownloaderDelegate : AnyObject {
  func backgroundDownload(didCompleteWithError error: Swift.Error, identifier: Swift.String)
  func backgroundDownload(didFinishDownloadingTo location: Foundation.URL, identifier: Swift.String)
}
@objc public class SWCBackgroundDownloader : ObjectiveC.NSObject {
  public var backgroundCompletionHandler: (() -> Swift.Void)?
  public init(identifier: Swift.String, urlString: Swift.String, delegate: SWCFramework.SWCBackgroundDownloaderDelegate?)
  @discardableResult
  public func start() -> Foundation.URLSessionDownloadTask
  @objc deinit
}
extension SWCFramework.SWCBackgroundDownloader : Foundation.URLSessionDelegate {
  @objc dynamic public func urlSessionDidFinishEvents(forBackgroundURLSession session: Foundation.URLSession)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
extension SWCFramework.SWCBackgroundDownloader : Foundation.URLSessionDownloadDelegate, Foundation.URLSessionTaskDelegate {
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
}
@objc final public class SWCNetworkEngine : ObjectiveC.NSObject {
  final public var moduleId: Swift.String?
  final public var validateTokenTimeStamp: Swift.Bool
  public init(moduleId: Swift.String? = nil, validateTokenTimeStamp: Swift.Bool = true, session: Foundation.URLSession? = nil)
  @objc deinit
  final public func getResponse<T, U>(with generator: T, responseType: U.Type, responseQueue: Dispatch.DispatchQueue = .main, jsonDecoder: Foundation.JSONDecoder = JSONDecoder()) -> SWCFramework.SWCResultObserver<U> where T : SWCFramework.SWCRequestSource, U : Swift.Decodable
  final public func getResponse<T>(with generator: T, responseQueue: Dispatch.DispatchQueue = .main) -> SWCFramework.SWCDictionaryResultObserver where T : SWCFramework.SWCRequestSource
}
extension SWCFramework.SWCNetworkEngine {
  final public func setResponseValidator(_ validator: SWCFramework.SWCResponseValidatorDelegate?)
  final public func disablePasswordExpiryNotification()
}
extension SWCFramework.SWCNetworkEngine {
  public static func clearAllRequests()
  public static func cancelCalls(for url: Swift.String)
}
extension SWCFramework.SWCNetworkEngine {
  #if compiler(>=5.3) && $AsyncAwait
  final public func getResponse<T, U>(with generator: T, responseType: U.Type, responseQueue: Dispatch.DispatchQueue = .main, jsonDecoder: Foundation.JSONDecoder = JSONDecoder()) async throws -> U where T : SWCFramework.SWCRequestSource, U : Swift.Decodable
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func getResponse<T>(with generator: T, responseQueue: Dispatch.DispatchQueue = .main) async throws -> [Swift.String : Any] where T : SWCFramework.SWCRequestSource
  #endif
}
extension SWCFramework.SWCNetworkEngine {
  final public func getResponse<T>(with generator: T, queue: Dispatch.DispatchQueue = .main) -> SWCFramework.SWCXMLResultObserver where T : SWCFramework.SWCRequestSource
  final public func getResponse<T, U>(with generator: T, responseType: U.Type, queue: Foundation.RunLoop = .main) -> SWCFramework.SWCXMLObserver<U> where T : SWCFramework.SWCRequestSource, U : SWCFramework.XMLParsable
}
public enum KeychainItemAccessibility {
  @available(iOS 4, *)
  case afterFirstUnlock
  @available(iOS 4, *)
  case afterFirstUnlockThisDeviceOnly
  @available(iOS 4, *)
  case always
  @available(iOS 8, *)
  case whenPasscodeSetThisDeviceOnly
  @available(iOS 4, *)
  case alwaysThisDeviceOnly
  @available(iOS 4, *)
  case whenUnlocked
  @available(iOS 4, *)
  case whenUnlockedThisDeviceOnly
  public static func == (a: SWCFramework.KeychainItemAccessibility, b: SWCFramework.KeychainItemAccessibility) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SWCFramework.SWCNetworkEngine {
  public struct Observers {
    public static let requestStarted: Combine.PassthroughSubject<SWCFramework.SWCRequestSource, Swift.Never>
    public static let requestEnded: Combine.PassthroughSubject<(SWCFramework.SWCRequestSource, Swift.Error?), Swift.Never>
  }
}
public protocol SWCCustomTypeConverter {
}
extension Swift.Dictionary : SWCFramework.SWCCustomTypeConverter {
}
extension Foundation.NSDictionary : SWCFramework.SWCCustomTypeConverter {
}
extension Swift.Array : SWCFramework.SWCCustomTypeConverter {
}
extension Swift.Int : SWCFramework.SWCCustomTypeConverter {
}
extension Swift.Float : SWCFramework.SWCCustomTypeConverter {
}
extension Swift.Double : SWCFramework.SWCCustomTypeConverter {
}
extension Swift.String : SWCFramework.SWCCustomTypeConverter {
}
public typealias KeychainKey = SWCFramework.KeychainWrapper.Key
@objc @_inheritsConvenienceInitializers final public class KeychainManager : ObjectiveC.NSObject {
  public static var keychainWrapper: SWCFramework.KeychainWrapper {
    get
  }
  public static func save(value: Swift.Int, forKey key: Swift.String)
  public static func save(value: Swift.Float, forKey key: Swift.String)
  public static func save(value: Swift.Double, forKey key: Swift.String)
  public static func save(value: Swift.Bool, forKey key: Swift.String)
  public static func save(value: Swift.String, forKey key: Swift.String)
  public static func save(value: Swift.Int, forKey key: SWCFramework.KeychainKey)
  public static func save(value: Swift.Float, forKey key: SWCFramework.KeychainKey)
  public static func save(value: Swift.Double, forKey key: SWCFramework.KeychainKey)
  public static func save(value: Swift.Bool, forKey key: SWCFramework.KeychainKey)
  public static func save(value: Swift.String, forKey key: SWCFramework.KeychainKey)
  public static func removeValue(forKey key: Swift.String)
  public static func removeValue(forKey key: SWCFramework.KeychainWrapper.Key)
  public static func removeAllKeys()
  public static func string(forKey key: Swift.String) -> Swift.String?
  public static func integer(forKey key: Swift.String) -> Swift.Int?
  public static func float(forKey key: Swift.String) -> Swift.Float?
  public static func double(forKey key: Swift.String) -> Swift.Double?
  public static func bool(forKey key: Swift.String) -> Swift.Bool?
  public static func string(forKey key: SWCFramework.KeychainWrapper.Key) -> Swift.String?
  public static func integer(forKey key: SWCFramework.KeychainWrapper.Key) -> Swift.Int?
  public static func float(forKey key: SWCFramework.KeychainWrapper.Key) -> Swift.Float?
  public static func double(forKey key: SWCFramework.KeychainWrapper.Key) -> Swift.Double?
  public static func bool(forKey key: SWCFramework.KeychainWrapper.Key) -> Swift.Bool?
  public static func removeAllValues()
  @objc override dynamic public init()
  @objc deinit
}
public typealias SWCResultObserver<T> = Combine.AnyPublisher<T, SWCFramework.NetworkError> where T : Swift.Decodable
public typealias SWCDictionaryResultObserver = Combine.AnyPublisher<[Swift.String : Any], SWCFramework.NetworkError>
public typealias SWCProgressPublisher = Combine.AnyPublisher<Swift.Double, SWCFramework.NetworkError>
public typealias SWCXMLObserver<T> = Combine.AnyPublisher<T.Element, SWCFramework.NetworkError> where T : SWCFramework.XMLParsable
public typealias SWCXMLResultObserver = Combine.AnyPublisher<SWCFramework.XMLIndexer, SWCFramework.NetworkError>
@objc @_inheritsConvenienceInitializers public class CommonLoader : ObjectiveC.NSObject {
  public class func showSpinner()
  public class var window: UIKit.UIWindow? {
    get
  }
  public class func hideSpinner()
  @objc override dynamic public init()
  @objc deinit
}
extension UIKit.UIWindow {
  @_Concurrency.MainActor(unsafe) public var visibleViewController: UIKit.UIViewController? {
    get
  }
  @_Concurrency.MainActor(unsafe) public static func getVisibleViewControllerFrom(_ vc: UIKit.UIViewController?) -> UIKit.UIViewController?
}
public struct SWCURLRequest : SWCFramework.SWCRequestSource {
  public var validateTokenTimeStamp: Swift.Bool
  public var showLoader: Swift.Bool
  public var urlRequest: Foundation.URLRequest
  public init(urlRequest: Foundation.URLRequest)
  public func generateRequest() -> Foundation.URLRequest
}
public protocol RootKeyParsable {
  static func rootKey() -> Swift.String
}
extension SWCFramework.RootKeyParsable {
  public static func rootKey() -> Swift.String
}
@objc @_inheritsConvenienceInitializers public class SWCDownloadEngine : ObjectiveC.NSObject {
  public var session: Foundation.URLSession {
    get
    set
  }
  public static let shared: SWCFramework.SWCDownloadEngine
  public func downloadTaskPublisher(with url: Swift.String, withLoader: Swift.Bool = false) -> Combine.AnyPublisher<SWCFramework.DownloadOutput, Swift.Error>
  @objc override dynamic public init()
  @objc deinit
}
extension SWCFramework.SWCDownloadEngine : Foundation.URLSessionDelegate {
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
public class PrivateKey : SWCFramework.Key {
  final public let key: Security.SecKey
  required public init(key: Security.SecKey)
  required public init?(der: Foundation.Data)
  public func pemString() throws -> Swift.String
  @objc deinit
}
public protocol XMLIndexerDeserializable {
  static func deserialize(_ element: SWCFramework.XMLIndexer) throws -> Self
  func validate() throws
}
extension SWCFramework.XMLIndexerDeserializable {
  public static func deserialize(_ element: SWCFramework.XMLIndexer) throws -> Self
  public func validate() throws
}
public protocol XMLElementDeserializable {
  static func deserialize(_ element: SWCFramework.XMLElement) throws -> Self
  func validate() throws
}
extension SWCFramework.XMLElementDeserializable {
  public static func deserialize(_ element: SWCFramework.XMLElement) throws -> Self
  public func validate() throws
}
public protocol XMLAttributeDeserializable {
  static func deserialize(_ attribute: SWCFramework.XMLAttribute) throws -> Self
  func validate() throws
}
extension SWCFramework.XMLAttributeDeserializable {
  public static func deserialize(attribute: SWCFramework.XMLAttribute) throws -> Self
  public func validate() throws
}
extension SWCFramework.XMLIndexer {
  public func value<T>(ofAttribute attr: Swift.String) throws -> T where T : SWCFramework.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) -> T? where T : SWCFramework.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) throws -> [T] where T : SWCFramework.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) throws -> [T]? where T : SWCFramework.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) throws -> [T?] where T : SWCFramework.XMLAttributeDeserializable
  public func value<T>() throws -> T where T : SWCFramework.XMLElementDeserializable
  public func value<T>() throws -> T? where T : SWCFramework.XMLElementDeserializable
  public func value<T>() throws -> [T] where T : SWCFramework.XMLElementDeserializable
  public func value<T>() throws -> [T]? where T : SWCFramework.XMLElementDeserializable
  public func value<T>() throws -> [T?] where T : SWCFramework.XMLElementDeserializable
  public func value<T>() throws -> T where T : SWCFramework.XMLIndexerDeserializable
  public func value<T>() throws -> T? where T : SWCFramework.XMLIndexerDeserializable
  public func value<T>() throws -> [T] where T : SWCFramework.XMLIndexerDeserializable
  public func value<T>() throws -> [T]? where T : SWCFramework.XMLIndexerDeserializable
  public func value<T>() throws -> [T?] where T : SWCFramework.XMLIndexerDeserializable
}
extension SWCFramework.XMLIndexer {
  public func value<T, A>(ofAttribute attr: A) throws -> T where T : SWCFramework.XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
  public func value<T, A>(ofAttribute attr: A) -> T? where T : SWCFramework.XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
  public func value<T, A>(ofAttribute attr: A) throws -> [T] where T : SWCFramework.XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
  public func value<T, A>(ofAttribute attr: A) throws -> [T]? where T : SWCFramework.XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
  public func value<T, A>(ofAttribute attr: A) throws -> [T?] where T : SWCFramework.XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
}
extension SWCFramework.XMLElement {
  public func value<T>(ofAttribute attr: Swift.String) throws -> T where T : SWCFramework.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) -> T? where T : SWCFramework.XMLAttributeDeserializable
}
extension SWCFramework.XMLElement {
  public func value<T, A>(ofAttribute attr: A) throws -> T where T : SWCFramework.XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
  public func value<T, A>(ofAttribute attr: A) -> T? where T : SWCFramework.XMLAttributeDeserializable, A : Swift.RawRepresentable, A.RawValue == Swift.String
}
public enum XMLDeserializationError : Swift.Error, Swift.CustomStringConvertible {
  case implementationIsMissing(method: Swift.String)
  case nodeIsInvalid(node: SWCFramework.XMLIndexer)
  case nodeHasNoValue
  case typeConversionFailed(type: Swift.String, element: SWCFramework.XMLElement)
  case attributeDoesNotExist(element: SWCFramework.XMLElement, attribute: Swift.String)
  case attributeDeserializationFailed(type: Swift.String, attribute: SWCFramework.XMLAttribute)
  @available(*, unavailable, renamed: "implementationIsMissing(method:)")
  public static func ImplementationIsMissing(method: Swift.String) -> SWCFramework.XMLDeserializationError
  @available(*, unavailable, renamed: "nodeHasNoValue(_:)")
  public static func NodeHasNoValue(_: SWCFramework.IndexOps) -> SWCFramework.XMLDeserializationError
  @available(*, unavailable, renamed: "typeConversionFailed(_:)")
  public static func TypeConversionFailed(_: SWCFramework.IndexingError) -> SWCFramework.XMLDeserializationError
  @available(*, unavailable, renamed: "attributeDoesNotExist(_:_:)")
  public static func AttributeDoesNotExist(_ attr: Swift.String, _ value: Swift.String) throws -> SWCFramework.XMLDeserializationError
  @available(*, unavailable, renamed: "attributeDeserializationFailed(_:_:)")
  public static func AttributeDeserializationFailed(_ attr: Swift.String, _ value: Swift.String) throws -> SWCFramework.XMLDeserializationError
  public var description: Swift.String {
    get
  }
}
extension Swift.String : SWCFramework.XMLElementDeserializable, SWCFramework.XMLAttributeDeserializable {
  public static func deserialize(_ element: SWCFramework.XMLElement) -> Swift.String
  public static func deserialize(_ attribute: SWCFramework.XMLAttribute) -> Swift.String
  public func validate()
}
extension Swift.Int : SWCFramework.XMLElementDeserializable, SWCFramework.XMLAttributeDeserializable {
  public static func deserialize(_ element: SWCFramework.XMLElement) throws -> Swift.Int
  public static func deserialize(_ attribute: SWCFramework.XMLAttribute) throws -> Swift.Int
  public func validate()
}
extension Swift.Double : SWCFramework.XMLElementDeserializable, SWCFramework.XMLAttributeDeserializable {
  public static func deserialize(_ element: SWCFramework.XMLElement) throws -> Swift.Double
  public static func deserialize(_ attribute: SWCFramework.XMLAttribute) throws -> Swift.Double
  public func validate()
}
extension Swift.Float : SWCFramework.XMLElementDeserializable, SWCFramework.XMLAttributeDeserializable {
  public static func deserialize(_ element: SWCFramework.XMLElement) throws -> Swift.Float
  public static func deserialize(_ attribute: SWCFramework.XMLAttribute) throws -> Swift.Float
  public func validate()
}
extension Swift.Bool : SWCFramework.XMLElementDeserializable, SWCFramework.XMLAttributeDeserializable {
  public static func deserialize(_ element: SWCFramework.XMLElement) throws -> Swift.Bool
  public static func deserialize(_ attribute: SWCFramework.XMLAttribute) throws -> Swift.Bool
  public func validate()
}
public protocol SWCResponseValidatorDelegate {
  func validate(for response: [Swift.String : Any]) -> SWCFramework.SWCResponseValidator
}
public protocol SWCUploadSource {
  func generateRequest() -> Foundation.URLRequest
  var showLoader: Swift.Bool { get }
  var fromFileURL: Foundation.URL { get }
}
public enum DownloadOutput {
  case complete(Foundation.URL)
  case downloading(progress: Swift.Double)
}
public struct SWCExternalRequestGenerator {
  public var httpBody: Foundation.Data?
  public var showLoader: Swift.Bool
  public var contentType: SWCFramework.ContentTypes
  public var accept: SWCFramework.ContentTypes
  public var httpMethod: SWCFramework.HTTPMethod
  public init(url: Swift.String, body: [Swift.String : Any]?)
  public mutating func setHeader(value: Swift.String, field: SWCFramework.HTTPHeaders)
}
extension SWCFramework.SWCExternalRequestGenerator : SWCFramework.SWCRequestSource {
  public func generateRequest() -> Foundation.URLRequest
  public var validateTokenTimeStamp: Swift.Bool {
    get
  }
}
public protocol XMLParsable {
  associatedtype Element
  static func initWith(dict: Foundation.NSDictionary) throws -> Self.Element
}
public enum UploadDownloadResponse {
  case progress(percentage: Swift.Double)
  case response(data: Foundation.Data?)
}
extension Foundation.NSNotification.Name {
  public static let passwordExpired: Foundation.Notification.Name
}
extension SWCFramework.ContentTypes : Swift.Equatable {}
extension SWCFramework.ContentTypes : Swift.Hashable {}
extension SWCFramework.ContentTypes : Swift.RawRepresentable {}
extension SWCFramework.HTTPHeaders : Swift.Equatable {}
extension SWCFramework.HTTPHeaders : Swift.Hashable {}
extension SWCFramework.HTTPHeaders : Swift.RawRepresentable {}
extension SWCFramework.HTTPMethod : Swift.Equatable {}
extension SWCFramework.HTTPMethod : Swift.Hashable {}
extension SWCFramework.HTTPMethod : Swift.RawRepresentable {}
extension SWCFramework.SWCResponseCode : Swift.Equatable {}
extension SWCFramework.SWCResponseCode : Swift.Hashable {}
extension SWCFramework.SWCResponseCode : Swift.RawRepresentable {}
extension SWCFramework.Language : Swift.Equatable {}
extension SWCFramework.Language : Swift.Hashable {}
extension SWCFramework.Language : Swift.RawRepresentable {}
extension SWCFramework.EncryptionType : Swift.Equatable {}
extension SWCFramework.EncryptionType : Swift.Hashable {}
extension SWCFramework.KeychainItemAccessibility : Swift.Equatable {}
extension SWCFramework.KeychainItemAccessibility : Swift.Hashable {}
